统一格式(general format)：
日期(date)：
题号(Question Number)：
Code:
Note: 
Tag: <all_lowercase> <language>

2020.7.31
#1
//
unordered_map<int, int> map;
map[i] = 1;
//
N: unordered_map is Hashmap
<cpp> <hashmap>

#26
// p is an iterator
if (*p != *(p+1) || (p+1) == nums.end())
This will cause index out of bound
==31==ERROR: AddressSanitizer: heap-buffer-overflow

if ((p+1) == nums.end() || *p != *(p+1))
This will not
//
Always checks boundary first.
<cpp> <debug>

#26
// using erase()
for(;iterator != vector.end();)
if (condition to erase) {
	vector.erase(iterator);
} else {
	iterator++;
}
erase will automatically make iterator + 1 become the next unremoved element.
<cpp> <erase()> <iterator>

#NULL
vector sort()
sort(vector.begin(), vector.end());
<cpp> <vector> <sort>

2020.8.2
#11
Two Pointer approach:
//
two iterators at begin() and end():
if (condition A) { 
	move the left iterator right
} else { 
	move the right iterator left
}
//
Used to find maximum with two variables.
O(n)
<algorithm> <two_pointers>

2020.8.3
#34
lower_bound(iterator, iterator, value)
return index for some value in a sorted vector
<cpp> <binary_search>

binary search (lower bound)
start = 0, end = size - 1
while (start <= end) {
	mid = (end - start) / 2 + start
	if ()
		start = mid + 1
	else 
		end = mid - 1
}
return start <------ /* !!! */ 
<algorithm> <binary_search>

2020.8.6
#208
TrieTree
one node for one character and every node has 26 children.
//
struct trieNode {
        bool isEnd;
        unordered_map<char, Node *> child;
}
/*
use a recursive helper function to do the search
*/
//
<structure> <trietree>

how to insert value into umap:
//
unordered_map[key] = value;
//

you can also do this:
//
for loop:
	Node * temp;
	umap[key] = temp;
end loop;
// <---- it works.
<cpp> <hashmap>

2020.8.7
#215
//
nth_element(iter.begin(), iter.target(), iter.end())
//
put the (target-begin)-th element in iter.target(), increasing order.

//
make_heap(iter.begin(), iter.end()) ---> void
heap_pop(iter.begin(), iter.end()) ---> void --> put the popped element in ( iter.end() - 1 )
//
<cpp> <heap>

#August Challenge day 7
//
sort(iter.begin(), iter.end()) ----> this is a void function!
//
<cpp> <sort()>

iterate through unordered_map:
//
for (auto & v : umap) {
	v.first ----> key
	v.second ----> value
}
//
<cpp> <hashmap>

2020.8.8
#August Challenge day 8
BST but you care about the depth of the row;
//
while (queue is not empty) {
	k = queue.size()
	while (k--) {
		/* function */
		enqueue(curr.left)
		enqueue(curr.right)
	}
}
//
don't care:
remove the inner nested loop
<algorithm> <bst>

2020.8.10
#21
create linked list:
need 3 nodes: root, curr, next
//
Node root = new Node()
Node curr = root

while()
Node next = new Node()
next.value = value
curr.next = next
curr = curr.next
//
<structure> <linkedlist> 

2020.8.14
#210
topological sort
method 1, dfs:
➔ let S be a stack of courses
➔ function dfs(node)
➔     for each neighbor in adjacency list of node
➔          dfs(neighbor)
➔     add node to S
need to keep a visited-node-list
need a adjacent node table

method 2, node indegree
➔ add node with 0 indegree
➔ node adjacent indegree - 1
➔ delete it
➔ repeat
<algorithm> <topological_sort>

2020.8.15
#435
sort(iter,iter,comp) 
(+static, when defined in a class) bool comp (a, b)
return true, then a < b
<sort()>

for i in array:
	if (false condition):
		...
	else:
		prev = curr ----> only set prev when true to find the longest chain
<algorithm> <greedy>

2020.8.16
#123
dynamic programming:
if you know how to get to your goal from position K, and there's only limited ways to get to position K, then that's a DP.
//
bestSale ---> highest profit if you sale at this point
bestBuy ---> highest profit if you buy at this point
both can be calculated in one iteration
//
<algorithm> <dynamic_programming>

2020.8.18
#3
find for vector: find(v.begin(), v.end(), value)
find for unordered_map: umap.find(key)
<find()> <cpp>

2020.8.19
#23
priority_queue in cpp
//
#include <queue>
//
<priority_queue> <cpp>

2020.8.21
measure running time in cpp:
//
auto t1 = std::chrono::high_resolution_clock::now();
duration<double, std::milli> time_span = t2 - t1;
std::cout << "It took me " << time_span.count() << " milliseconds.";
//
<timer> <cpp>

#496
Next Greater Element:
stack:
	while (stack not empty and stack.top < curr) {
		top = stack.pop
		top.nextGreater = curr;
	}
	stack.push(curr)

stack must be in a descending order
so compare current element with 1-n top element, if greater, then we find it.

#1032
Find Word in Character Stream:
TrieTree:
but reverse word and find prefix
<trietree> <algorithm>